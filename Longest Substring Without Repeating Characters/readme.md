这道题我并没有给出实现而是去直接看了讨论(捂脸)

我选出了我最喜欢的实现,因为它比较巧妙而且复杂度也只有O(n)

大概实现的思路是如此,char 数据类型的长度空间 1 byte.

设定ASCII及ASCII扩展字符为0-255的值域,给定一个向量去记录每一个ASCII字符出现的位置,所有字符第一次出现时都不会修改start的值,直到该字符下一次出现:

此时start的值修改了,直到下次有某个字符的第二次出现位置大于当前start值,start才会出现,在遍历过程中计算子川的最大长度即可.

或者不出现:

返回最长子串的长度就是自身的长度 n = i + 1
